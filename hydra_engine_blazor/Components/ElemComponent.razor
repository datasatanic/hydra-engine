@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Text.Encodings.Web
@using hydra_engine_blazor.Models
@using System.Globalization
@using System.ComponentModel.DataAnnotations
@using System.Runtime.InteropServices
@using System.Text
@using System.Text.Json.Nodes
@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime
@inject SettingsContainer SettingsContainer
@implements IAsyncDisposable
@if (elemInfo != null)
{
    @if (elemInfo.type != ElemType.Array)
    {
        <div class="position-relative">
            @switch (elemInfo.control)
            {
                case Control.Label:
                {
                    var id = elemInfo.GetHashCode();
                    <ul>
                        <li>@elemInfo.display_name
                            <img data-bs-toggle="collapse" data-bs-target="@($"#el{id}")" aria-controls="@($"el{id}")" aria-expanded="@(Depth <= 2 ? "true" : "false")"/>
                        </li>
                        <div class="collapse @(Depth <= 2 ? "show" : "") nested-element" id="@($"el{id}")">
                            <ul class="elements-container">
                                @foreach (var (key,value) in elemInfo.sub_type_schema)
                                {
                                    <li>
                                        @{
                                            <ElemComponent Key="@key" elemInfo="@value" SendValue="@((ElemInfo obj) => HandleChanges(obj, key))" Depth = "@(Depth + 1)"></ElemComponent>
                                        }
                                    </li>
                                }
                            </ul>
                        </div>
                    </ul>
                }
                    break;
                case Control.Textarea:
                    <div class="elem-container">
                        <h4>@elemInfo.display_name</h4>
                        <textarea @attributes="ElementAttributes" validation-error="@(!TryParseToType(elemInfo.value, elemInfo?.type))" @onchange="@((e)=>ChangeValue(e,elemInfo.type))">@elemInfo?.value</textarea>
                    </div>
                    break;
                default:
                    <div class="elem-container @(elemInfo.control==Control.Checkbox ? "elem-reverse" : "")">
                        <h4>@elemInfo.display_name</h4>
                        <input @attributes="ElementAttributes" validation-error="@(!TryParseToType(elemInfo.value, elemInfo?.type))" size="@(elemInfo?.value != null ? elemInfo.value.ToString().Length : 0)" value="@(elemInfo.control==Control.Checkbox ? "bool" : elemInfo.value)" @onchange="@((e)=>ChangeValue(e,elemInfo.type))"/>
                    </div>
                    break;

            }
            @if (elemInfo.value == null || string.IsNullOrEmpty(elemInfo?.value.ToString()))
            {
                <div class="validation-message">Enter field</div>
                
            }
            else if (!TryParseToType(elemInfo.value,elemInfo?.type))
            {
                <div class="validation-message">Not @elemInfo.type type</div>
            }
            else
            {
                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(elemInfo.value, item, elemInfo.control)))
                {
                    <div class="validation-message">@(constraintItem.message ?? $"{constraintItem.type}:{constraintItem.value}")</div>
                                                                                                                                
                }
            }  
        </div>
    }
    else
    {
        <div class="elem-container">
            <fieldset>
                <legend>@elemInfo.display_name
                    @if (!elemInfo.readOnly)
                    {
                        <img @onclick="AddItem"/>
                    }
                </legend>
                <div class="d-flex flex-column gap-3 overflow-auto">
                    @{var arrayItems = elemInfo?.value as List<object> ?? new List<object>();}
                    @if (elemInfo.array_sub_type_schema != null)
                    {
                        for (var i = 0; i < elemInfo.array_sub_type_schema.Count; i++)
                        {
                            var j = i;
                            var subTypeSchema = elemInfo.array_sub_type_schema[j];
                            <div class="elements-container" id="@SettingsContainer.GetHash(Key + j)">
                                @foreach (var (key, value) in subTypeSchema)
                                {
                                    <div class="position-relative">
                                        <ElemComponent Key="@key" elemInfo="@value" SendValue="@((ElemInfo obj) => HandleArrayChanges(obj, key, j))" Depth="@(Depth + 1)"></ElemComponent>
                                    </div>
                                }
                                @if (!elemInfo.readOnly)
                                {
                                    <img class="delete-image" @onclick="@(() => RemoveArrayItem(j))"/>
                                }
                                <hr/>
                            </div>
                        }
                    }
                    else
                    {
                        for (var i = 0; i < arrayItems.Count; i++)
                            {
                                var j = i;
                                var elem = (elemInfo.value as List<object>)[j];
                                <div id="@SettingsContainer.GetHash(Key + j)">
                                    @switch (elemInfo?.control)
                                    {
                                        case Control.Textarea:
                                            <div class="list-item-container">
                                                <textarea @attributes="ElementAttributes" validation-error="@(!TryParseToType(elem, elemInfo?.sub_type))" @onchange="@((e) => ChangeArrayValue(e, j, elemInfo.sub_type))">@elem</textarea>
                                                @if (!elemInfo.readOnly)
                                                {
                                                    <img @onclick="@(() => RemoveArrayItem(j))"/>
                                                }
                                            </div>
                                            break;
                                        default:
                                            <div class="list-item-container">
                                                <input @attributes="ElementAttributes" size="@(elem != null ? elem.ToString().Length : 0)" validation-error="@(!TryParseToType(elem, elemInfo?.sub_type))" value="@elem" @onchange="@((e) => ChangeArrayValue(e, j, elemInfo.sub_type))"/>
                                                @if (!elemInfo.readOnly)
                                                {
                                                    <img @onclick="@(() => RemoveArrayItem(j))"/>
                                                }
                                            </div>
                                            break;
                                    }
                                    @if (elem == null || string.IsNullOrEmpty(elem.ToString()))
                                    {
                                        <div class="validation-message">Enter field</div>
                                    }
                                    else if (!TryParseToType(elem, elemInfo?.sub_type))
                                    {
                                        <div class="validation-message">Not @elemInfo?.sub_type type</div>
                                    }
                                    else
                                    {
                                        foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(elem, item, elemInfo.control)))
                                        {
                                            <div class="validation-message">@(constraintItem.message ?? $"{constraintItem.type}:{constraintItem.value}")</div>
                                        }
                                    }
                                </div>
                            }
                    }
                </div>
            </fieldset>
        </div>
    }

}

@code {
    [Parameter]
    public string Key { get; set; }
    [Parameter] public EventCallback<ElemInfo> SendValue { get; set; }
    [Parameter]
    public ElemInfo? elemInfo { get; set; }
    [Parameter]
    public int Depth { get; set; }

    private string filePath => elemInfo.fileId;
    private Dictionary<string, object>? ElementAttributes { get; set; } = new();

    private JsonSerializerOptions options = new()
    {
        Converters =
        {
            new JsonStringEnumConverter()
        },
    };
    IJSObjectReference? _module;
    private bool _canScroll;
    protected override void OnParametersSet()
    {
        ElementAttributes = new Dictionary<string, object>
        {
            {"disabled",elemInfo?.readOnly},
            {"tabindex",1},
            {"title",elemInfo?.description}
        };
        AddElementAttributes(elemInfo);
    }

    protected override async Task OnInitializedAsync()
    {
        if (elemInfo is {type: ElemType.Array })
        {
            if (elemInfo.value is List<object> arrayItems && arrayItems.Any(elem => !TryParseToType(elem.ToString() ?? "", elemInfo.sub_type)))
            {
                elemInfo.isValid = false;
                await SendValue.InvokeAsync(elemInfo);
            }
        }
        else
        {
            var value = elemInfo?.value ?? string.Empty;
            if (!TryParseToType(value.ToString() ?? string.Empty, elemInfo.type))
            {
                elemInfo.isValid = false;
                await SendValue.InvokeAsync(elemInfo);
            }
        }
        
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./Components/ElemComponent.razor.js");
        }
        else
        {
            if (_canScroll)
            {
                var id = SettingsContainer.GetHash(Key + $"{(elemInfo.value as List<object>).Count - 1}");
                await _module.InvokeVoidAsync("Scroll", id);
                _canScroll = false;
            }
        }
    }

    private bool TryParseToType(object? value,ElemType? type)
    {
        var valueString = value != null ? value.ToString() : string.Empty;
        if (string.IsNullOrEmpty(valueString))
        {
            return false;
        }
        return type switch
        {
            ElemType.Double => CultureInfo.CurrentCulture.TwoLetterISOLanguageName switch
            {
                "en" => double.TryParse(valueString.Replace(",", "."), out _),
                "ru" => double.TryParse(valueString.Replace(".", ","), out _),
                _ => false
                },
            ElemType.Int => int.TryParse(valueString, out _),
            ElemType.DateTime => DateTime.TryParse(valueString, out _),
            ElemType.Bool => bool.TryParse(valueString, out _),
            _ => true
            };
    }

    private async Task ChangeValue(ChangeEventArgs obj,ElemType type)
    {
        if (elemInfo.readOnly)
        {
            elemInfo.isValid = false;
            await SendValue.InvokeAsync(elemInfo);
            return;
        }
        var value = obj.Value;
        elemInfo.value = value;
        if (TryParseToType(value.ToString(),elemInfo?.type) && !string.IsNullOrEmpty(value.ToString()) && !elemInfo.constraints.Exists(item=>!CheckConstraints(value.ToString(),item,elemInfo.control)))
        {
            ElementAttributes["validation-error"] = false;
            elemInfo.isValid = true;
            switch (type)
            {
                case ElemType.String:
                    elemInfo.value = value;
                    break;
                case ElemType.Int:
                    elemInfo.value = int.Parse(value.ToString());
                    break;
                case ElemType.Double:
                    elemInfo.value = CultureInfo.CurrentCulture.TwoLetterISOLanguageName switch
                    {
                        "en" => double.Parse(value.ToString().Replace(",", ".")),
                        "ru" => double.Parse(value.ToString().Replace(".", ",")),
                        _ => elemInfo.value
                        };
                    break;
                case ElemType.Bool:
                    elemInfo.value = bool.Parse(value.ToString());
                    break;
                case ElemType.DateTime:
                    elemInfo.value = DateTime.Parse(value.ToString());
                    break;
            }
        }
        else
        {
            elemInfo.isValid = false;
        }
        await SendValue.InvokeAsync(elemInfo);
    }

    private async Task ChangeArrayValue(ChangeEventArgs obj,int i,ElemType type)
    {
        if (elemInfo.readOnly)
        {
            elemInfo.isValid = false;
            await SendValue.InvokeAsync(elemInfo);
            return;
        }
        var arrayItems = elemInfo.value as List<object>;
        arrayItems[i]=obj.Value?.ToString();
        if (arrayItems.Find(item => !TryParseToType(item?.ToString(), elemInfo?.sub_type) |
                                              string.IsNullOrEmpty(item.ToString()) | elemInfo.constraints.Exists(item=>!CheckConstraints(item.ToString(),item,elemInfo.control))) == null)
        {
            elemInfo.isValid = true;
            switch (type)
            {
                case ElemType.String:
                    elemInfo.value = arrayItems;
                    break;
                case ElemType.Int:
                    elemInfo.value = arrayItems.Select(item => int.Parse(item.ToString())).ToList();
                    break;
                case ElemType.Double:
                    switch (CultureInfo.CurrentCulture.TwoLetterISOLanguageName)
                    {
                        case "en":
                            elemInfo.value = arrayItems.Select(item => double.Parse(item.ToString().Replace(",", "."))).ToList();
                            break;
                        case "ru":
                            elemInfo.value = arrayItems.Select(item => double.Parse(item.ToString().Replace(",", "."))).ToList();
                            break;
                    }
                    break;
                case ElemType.Bool:
                    elemInfo.value = arrayItems.Select(item => bool.Parse(item.ToString())).ToList();
                    break;
                case ElemType.DateTime:
                    elemInfo.value = arrayItems.Select(item => DateTime.Parse(item.ToString())).ToList();
                    break;
            }
        }
        else
        {
            elemInfo.isValid = false;
        }
        await SendValue.InvokeAsync(elemInfo);
    }
    private void AddElementAttributes(ElemInfo? elemInfo)
    {
        switch (elemInfo?.control)
        {
            case Control.Text:
                ElementAttributes?.Add("type","text");
                break;
            case Control.Password:
                ElementAttributes?.Add("type","password");
                break;
            case Control.Date:
                ElementAttributes?.Add("type","date");
                break;
            case Control.Datetime:
                ElementAttributes?.Add("type","datetime-local");
                break;
            case Control.Time:
                ElementAttributes?.Add("type","time");
                break;
            case Control.Number:
                ElementAttributes?.Add("type","number");
                break;
            case Control.Checkbox:
                ElementAttributes?.Add("type","checkbox");
                ElementAttributes?.Add("checked", bool.Parse(elemInfo.value.ToString()));
                break;
        }
        if (elemInfo.constraints is null)
        {
            elemInfo.constraints = new List<ConstraintItem>();
        }
        foreach (var constraint in elemInfo.constraints)
        {
            ElementAttributes?.Add(constraint.type, constraint.value);
        }
    }

    private async Task RemoveArrayItem(int pos)
    {
        elemInfo.isValid = true;
        var arrayItems = elemInfo.value as List<object?>;
        arrayItems?.RemoveAt(pos);
        if (elemInfo.array_sub_type_schema != null)
        {
            elemInfo.array_sub_type_schema.RemoveAt(pos);
            foreach (var item in elemInfo.array_sub_type_schema)
            {
                CheckValidation(item);
            }
        }
        else
        {
            if ( arrayItems?.
                Find(item => !TryParseToType(item?.ToString(), elemInfo?.sub_type) |
                             string.IsNullOrEmpty(item.ToString()) | elemInfo.constraints.Exists(item => !CheckConstraints(item.ToString(), item, elemInfo.control))) != null)
            {
                elemInfo.isValid = false;
            } 
        }
        await SendValue.InvokeAsync(elemInfo);
    }

    private Dictionary<string, object> GetSchema(Dictionary<string,ElemInfo> schema)
    {
        var dict = new Dictionary<string, object>();
        foreach (var kvp in schema)
        {
            var subElemInfo = kvp.Value.DeepCopy();
            dict.Add(kvp.Key,subElemInfo.value);
            if (subElemInfo.sub_type_schema == null) continue;
            var subDict = GetSchema(subElemInfo.sub_type_schema);
            dict[kvp.Key] = subDict;
        }
        return dict;
    }

    private Dictionary<string, ElemInfo> ChangeReadonly(Dictionary<string, ElemInfo> schema)
    {
        var dict = new Dictionary<string, ElemInfo>();
        foreach (var kvp in schema)
        {
            var subElemInfo = kvp.Value.DeepCopy();
            if (subElemInfo.sub_type_schema != null)
            {
                var subDict = ChangeReadonly(subElemInfo.sub_type_schema);
                subElemInfo.sub_type_schema = subDict;
            }
            subElemInfo.readOnly = false;
            subElemInfo.isValid = TryParseToType(subElemInfo.value.ToString(), subElemInfo.type) && !string.IsNullOrEmpty(subElemInfo.value.ToString()) && !subElemInfo.constraints.Exists(item => !CheckConstraints(subElemInfo.value.ToString(), item, subElemInfo.control));
            dict.Add(kvp.Key, subElemInfo);
            
        }
        return dict;
    }
    private async Task AddItem()
    {
        var arrayItems = elemInfo?.value as List<object>;
        if (elemInfo?.sub_type_schema != null)
        {
            var subTypeSchema = ChangeReadonly(elemInfo.sub_type_schema);
            CheckValidation(subTypeSchema);
            elemInfo?.array_sub_type_schema?.Add(subTypeSchema);
            var valueDictionary = GetSchema(elemInfo.sub_type_schema);
            arrayItems?.Add(valueDictionary);
        }
        else
        {
            arrayItems?.Add(string.Empty);
            elemInfo.isValid = false;
        }
        _canScroll = true;
        await SendValue.InvokeAsync(elemInfo);
    }

    private bool CheckConstraints(object? value, ConstraintItem constraintItem,Control control)
    {
        var stringValue = value != null ? value.ToString() : string.Empty;
        return stringValue != null && constraintItem.type switch
        {
            "maxlength" => int.Parse(constraintItem.value) > stringValue.Length,
            "minlength" => int.Parse(constraintItem.value) < stringValue.Length,
            "max" => control switch
            {
                Control.Number or Control.Text or Control.Textarea => int.Parse(constraintItem.value) > int.Parse(stringValue),
                Control.Datetime or Control.Date or Control.Time => DateTime.Parse(constraintItem.value) > DateTime.Parse(stringValue),
                _ => true
                },
            "min" => control switch
            {
                Control.Number or Control.Text or Control.Textarea => int.Parse(constraintItem.value) < int.Parse(stringValue),
                Control.Datetime or Control.Date or Control.Time => DateTime.Parse(constraintItem.value) < DateTime.Parse(stringValue),
                _ => true
                },
            "pattern" => Regex.IsMatch(stringValue, constraintItem.value, RegexOptions.IgnoreCase),
            _ => true
            };
    }

    private async Task HandleChanges(ElemInfo obj, string key)
    {
        if (elemInfo != null)
        {
            elemInfo.isValid = true;
            var dict = elemInfo.value as Dictionary<string, object>;
            if (elemInfo.sub_type_schema != null)
            {
                elemInfo.sub_type_schema[key] = obj;
                if (dict != null)
                {
                    dict[key] = obj.value;
                    CheckValidation(elemInfo.sub_type_schema);
                }
            }
            await SendValue.InvokeAsync(elemInfo);
        }
    }
    private async Task HandleArrayChanges(ElemInfo obj, string key,int index)
    {
        elemInfo.isValid = true;
        if (elemInfo.value is List<object?> arr)
        {
            if (arr[index] is Dictionary<string, object> dict)
            {
                dict[key] = obj.value;
            }
            elemInfo.array_sub_type_schema[index][key] = obj;
            foreach (var item in elemInfo.array_sub_type_schema)
            {
                CheckValidation(item);
            }
            await SendValue.InvokeAsync(elemInfo);
        }
        
    }

    private void CheckValidation(Dictionary<string, ElemInfo> item)
    {
        foreach (var (key,subElemInfo) in item)
        {
            if (subElemInfo.sub_type_schema != null)
            {
                CheckValidation(subElemInfo.sub_type_schema);
            }
            if (subElemInfo.isValid) continue;
            elemInfo.isValid = false;
            break;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_module != null) await _module.DisposeAsync();
    }

}