@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Text.Encodings.Web
@using hydra_engine_blazor.Models
@using System.Globalization
@using System.ComponentModel.DataAnnotations
@using System.Runtime.InteropServices
@using System.Text
@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime
@inject SettingsContainer SettingsContainer
@if (elemInfo != null)
{
    @if (elemInfo.type != ElemType.Array)
    {
        switch (elemInfo.control)
        {
            case Control.Textarea:
                <div class="elem-container">
                    <h4>@elemInfo.display_name</h4>
                    <textarea @attributes="ElementAttributes" @onchange="@((e)=>ChangeValue(e,Value,elemInfo.type))">@Value</textarea>
                </div>
                break;
            case Control.Range:
                <div class="elem-container">
                    <h4>@elemInfo.display_name</h4>
                    @{var range=JsonSerializer.Deserialize<Dictionary<string, object>>(Value.ToString());}
                    <div class="elem-container">
                        <div class="position-relative">
                            <h4>From</h4>
                            <input type="number" validation-error="@(!TryParseToType(range?.GetValueOrDefault("from", "").ToString(), ElemType.Int))" value="@range?.GetValueOrDefault("from", "")" @onchange="@((e) => ChangeRangeValue(e, range?.GetValueOrDefault("from", ""), true))"/>
                            @if (string.IsNullOrEmpty(range.GetValueOrDefault("from", "").ToString()))
                            {
                                <div class="validation-message range-error">Enter field</div>
                            }
                            else if (!TryParseToType(range.GetValueOrDefault("from", "").ToString(), ElemType.Int))
                            {
                                <div class="validation-message range-error">Not @ElemType.Int type</div>
                            }
                            else
                            {
                                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(range.GetValueOrDefault("from", "").ToString(), item, elemInfo.control)))
                                {
                                    <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                                }
                            }
                        </div>
                        <div class="position-relative">
                            <h4>To</h4>
                            <input type="number" validation-error="@(!TryParseToType(range?.GetValueOrDefault("to", "").ToString(), ElemType.Int))" value="@range?.GetValueOrDefault("to", "")" @onchange="@((e) => ChangeRangeValue(e, range?.GetValueOrDefault("to", ""), false))"/>
                            @if (string.IsNullOrEmpty(range.GetValueOrDefault("to", "").ToString()))
                            {
                                <div class="validation-message range-error">Enter field</div>
                            }
                            else if (!TryParseToType(range.GetValueOrDefault("to", "").ToString(), ElemType.Int))
                            {
                                <div class="validation-message range-error">Not @ElemType.Int type</div>
                            }
                            else
                            {
                                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(range.GetValueOrDefault("to", "").ToString(), item, elemInfo.control)))
                                {
                                    <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                                }
                            }
                        </div>
                    </div>
                </div>
                break;
            default:
                <div class="elem-container @(elemInfo.control==Control.Checkbox ? "elem-reverse" : "")">
                    <h4>@elemInfo.display_name</h4>
                    <input @attributes="ElementAttributes" size="@(Value?.ToString()?.Length)" value="@(elemInfo.control==Control.Checkbox ? "bool" : Value)" @onchange="@((e)=>ChangeValue(e,Value,elemInfo.type))"/>
                </div>
                break;

        }
        @if (elemInfo.type != ElemType.Range)
        {
            @if (string.IsNullOrEmpty(Value?.ToString()))
            {
                <div class="validation-message">Enter field</div>
            }
            else if (!TryParseToType(Value.ToString(),elemInfo?.type))
            {
                <div class="validation-message">Not @elemInfo.type type</div>
            }
            else
            {
                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(Value.ToString(), item, elemInfo.control)))
                {
                    <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                }
            }
            
        }
    }
    else
    {
        <div class="elem-container">
            <fieldset>
                <legend>@elemInfo.display_name
                    <img @onclick="AddItem"/>
                </legend>
                <div class="d-flex flex-column gap-3">
                    @if (elemInfo.sub_type == ElemType.Range)
                    {
                        <div class="range-titles-container">
                            <h4>From</h4>
                            <h4>To</h4>
                        </div>
                    }
                    @for (var i = 0; i < elemInfo?.arrayItems.Count; i++)
                    {
                        var j = i;
                        var elem = elemInfo?.arrayItems[j];
                        <div class="position-relative">
                            @switch (elemInfo?.control)
                            {
                                case Control.Textarea:
                                    <div class="list-item-container">
                                        <textarea @attributes="ElementAttributes" validation-error="@(!TryParseToType(elem.ToString(), elemInfo?.sub_type))" @onchange="@((e) => ChangeArrayValue(e, j, elemInfo.sub_type))">@elem</textarea>
                                        <img @onclick="@(() => RemoveArrayItem(j))"/>
                                    </div>
                                    break;
                                case Control.Range:
                                    var range = JsonSerializer.Deserialize<Dictionary<string, object>>(elem.ToString());
                                    <div class="elem-container">
                                        <div class="position-relative">
                                            <input type="number" value="@range?.GetValueOrDefault("from", "")" validation-error="@(!TryParseToType(range?.GetValueOrDefault("from", "").ToString(), ElemType.Int))" @onchange="@((e) => ChangeArrayRangeValue(e, j, true))"/>
                                            @if (string.IsNullOrEmpty(range.GetValueOrDefault("from", "").ToString()))
                                            {
                                                <div class="validation-message">Enter field</div>
                                            }
                                            else if (!TryParseToType(range.GetValueOrDefault("from", "").ToString(), ElemType.Int))
                                            {
                                                <div class="validation-message">Not @ElemType.Int type</div>
                                            }
                                            else
                                            {
                                                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(range.GetValueOrDefault("from", "").ToString(), item, elemInfo.control)))
                                                {
                                                    <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                                                }
                                            }
                                        </div>
                                        <div class="position-relative">
                                            <input type="number" value="@range?.GetValueOrDefault("to", "")" validation-error="@(!TryParseToType(range?.GetValueOrDefault("to", "").ToString(), ElemType.Int))" @onchange="@((e) => ChangeArrayRangeValue(e, j, false))"/>
                                            @if (string.IsNullOrEmpty(range.GetValueOrDefault("to", "").ToString()))
                                            {
                                                <div class="validation-message">Enter field</div>
                                            }
                                            else if (!TryParseToType(range.GetValueOrDefault("to", "").ToString(), ElemType.Int))
                                            {
                                                <div class="validation-message">Not @ElemType.Int type</div>
                                            }
                                            else
                                            {
                                                foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(range.GetValueOrDefault("to", "").ToString(), item, elemInfo.control)))
                                                {
                                                    <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                                                }
                                            }
                                        </div>
                                        <img class="delete-image" @onclick="@(() => RemoveArrayItem(j))"/>
                                    </div>
                                    break;
                                default:
                                    <div class="list-item-container">
                                        <input @attributes="ElementAttributes" validation-error="@(!TryParseToType(elem.ToString(), elemInfo?.sub_type))" value="@elem" @onchange="@((e) => ChangeArrayValue(e, j, elemInfo.sub_type))"/>
                                        <img @onclick="@(() => RemoveArrayItem(j))"/>
                                    </div>
                                    break;
                            }
                            @if (elemInfo?.sub_type != ElemType.Range)
                            {
                                @if (string.IsNullOrEmpty(elem.ToString()))
                                {
                                    <div class="validation-message">Enter field</div>
                                }
                                else if (!TryParseToType(elem.ToString(), elemInfo?.sub_type))
                                {
                                    <div class="validation-message">Not @elemInfo?.sub_type type</div>
                                }
                                else
                                {
                                    foreach (var constraintItem in elemInfo.constraints.Where(item => !CheckConstraints(elem.ToString(), item, elemInfo.control)))
                                    {
                                        <div class="validation-message">@constraintItem.type:@constraintItem.value</div>
                                    }
                                }
                                
                            }
                        </div>
                    }
                </div>
            </fieldset>
        </div>
    }

}

@code {
    [Parameter]
    public string Key { get; set; }
    [Parameter] public EventCallback<ElemInfo> SendValue { get; set; }
    [Parameter]
    public ElemInfo? elemInfo { get; set; }

    private string filePath => elemInfo.fileId;
    private object? Value { get; set; }
    private Dictionary<string, object>? ElementAttributes { get; set; } = new();

    private JsonSerializerOptions options = new()
    {
        Converters =
        {
            new JsonStringEnumConverter()
        },
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };

    protected override void OnInitialized()
    {
        ElementAttributes = new Dictionary<string, object>
        {
            {"disabled",elemInfo?.readOnly},
            {"tabindex",1},
            {"title",elemInfo?.description},
            {"validation-error",false}
        };
        Value = elemInfo.value;
        if (elemInfo.type == ElemType.Array)
        {
            elemInfo.arrayItems = JsonSerializer.Deserialize<List<object>>(Value.ToString(),options);
        }
        elemInfo.isValid = true;
        AddElementAttributes(elemInfo);
    }


    private bool TryParseToType(string value,ElemType? type)
    {
        if (string.IsNullOrEmpty(value))
        {
            return false;
        }
        return type switch
        {
            ElemType.Double => CultureInfo.CurrentCulture.TwoLetterISOLanguageName switch
            {
                "en" => double.TryParse(value.Replace(",", "."), out _),
                "ru" => double.TryParse(value.Replace(".", ","), out _),
                _ => false
                },
            ElemType.Int => int.TryParse(value, out _),
            ElemType.DateTime => DateTime.TryParse(value, out _),
            ElemType.Bool => bool.TryParse(value, out _),
            _ => true
            };
    }

    private async Task ChangeValue(ChangeEventArgs obj,object? value,ElemType type)
    {
        Value = obj.Value?.ToString();
        value = obj.Value?.ToString();
        if (TryParseToType(value.ToString(),elemInfo?.type) && !string.IsNullOrEmpty(value.ToString()) && !elemInfo.constraints.Exists(item=>!CheckConstraints(value.ToString(),item,elemInfo.control)))
        {
            ElementAttributes["validation-error"] = false;
            elemInfo.isValid = true;
            switch (type)
            {
                case ElemType.String:
                    elemInfo.value = value;
                    break;
                case ElemType.Int:
                    elemInfo.value = int.Parse(value.ToString());
                    break;
                case ElemType.Double:
                    elemInfo.value = CultureInfo.CurrentCulture.TwoLetterISOLanguageName switch
                    {
                        "en" => double.Parse(value.ToString().Replace(",", ".")),
                        "ru" => double.Parse(value.ToString().Replace(".", ",")),
                        _ => elemInfo.value
                        };
                    break;
                case ElemType.Bool:
                    elemInfo.value = bool.Parse(value.ToString());
                    break;
                case ElemType.DateTime:
                    elemInfo.value = DateTime.Parse(value.ToString());
                    break;
            }
        }
        else
        {
            ElementAttributes["validation-error"] = true;
            elemInfo.isValid = false;
        }
        await SendValue.InvokeAsync(elemInfo);
    }

    private async Task ChangeRangeValue(ChangeEventArgs obj, object? value,bool isStart)
    {
        var range=JsonSerializer.Deserialize<Dictionary<string, object>>(Value.ToString());
        if (TryParseToType(obj.Value.ToString(), ElemType.Int) && !string.IsNullOrEmpty(obj.Value.ToString()) && !elemInfo.constraints.Exists(item=>!CheckConstraints(obj.Value.ToString(),item,elemInfo.control)))
        {
            if (isStart)
            {
                range["from"] = int.Parse(obj.Value.ToString());
            }
            else
            {
                range["to"] = int.Parse(obj.Value.ToString());
            }
            elemInfo.isValid = true;
        }
        else
        {
            if (isStart)
            {
                range["from"] = obj.Value.ToString();
            }
            else
            {
                range["to"] = obj.Value.ToString();
            }
            elemInfo.isValid = false;
        }
        Value = JsonSerializer.Serialize(range);
        elemInfo.value = Value;
        await SendValue.InvokeAsync(elemInfo);
    }

    private async Task ChangeArrayValue(ChangeEventArgs obj,int i,ElemType type)
    {
        elemInfo.arrayItems[i]=obj.Value?.ToString();
        if (elemInfo?.arrayItems.Find(item => !TryParseToType(item?.ToString(), elemInfo?.sub_type) |
                                              string.IsNullOrEmpty(item.ToString()) | elemInfo.constraints.Exists(item=>!CheckConstraints(item.ToString(),item,elemInfo.control))) == null)
        {
            elemInfo.isValid = true;
            switch (type)
            {
                case ElemType.String:
                    elemInfo.value = elemInfo.arrayItems;
                    break;
                case ElemType.Int:
                    elemInfo.value = elemInfo?.arrayItems.Select(item => int.Parse(item.ToString())).ToList();
                    break;
                case ElemType.Double:
                    List<double>? doubleArray;
                    switch (CultureInfo.CurrentCulture.TwoLetterISOLanguageName)
                    {
                        case "en":
                            elemInfo.value = elemInfo?.arrayItems.Select(item => double.Parse(item.ToString().Replace(",", "."))).ToList();
                            break;
                        case "ru":
                            elemInfo.value = elemInfo?.arrayItems.Select(item => double.Parse(item.ToString().Replace(",", "."))).ToList();
                            break;
                    }
                    break;
                case ElemType.Bool:
                    elemInfo.value = elemInfo?.arrayItems.Select(item => bool.Parse(item.ToString())).ToList();
                    break;
                case ElemType.DateTime:
                    elemInfo.value = elemInfo?.arrayItems.Select(item => DateTime.Parse(item.ToString())).ToList();
                    break;
            }
        }
        else
        {
            elemInfo.isValid = false;
        }
        await SendValue.InvokeAsync(elemInfo);
    }

    private async Task ChangeArrayRangeValue(ChangeEventArgs obj, int i, bool isStart)
    {
        var range=JsonSerializer.Deserialize<Dictionary<string, object>>(elemInfo.arrayItems[i].ToString());
        if (TryParseToType(obj.Value.ToString(), ElemType.Int) && !string.IsNullOrEmpty(obj.Value.ToString()) && !elemInfo.constraints.Exists(item=>!CheckConstraints(obj.Value.ToString(),item,elemInfo.control)))
        {
            if (isStart)
            {
                range["from"] = int.Parse(obj.Value.ToString());
            }
            else
            {
                range["to"] = int.Parse(obj.Value.ToString());
            }
        }
        else
        {
            if (isStart)
            {
                range["from"] = obj.Value.ToString();
            }
            else
            {
                range["to"] = obj.Value.ToString();
            }
        }
        elemInfo.arrayItems[i] = JsonSerializer.Serialize(range,options);
        elemInfo.isValid = true;
        elemInfo.value = JsonSerializer.Serialize(elemInfo.arrayItems,options).Replace("\"{", "{").Replace("}\"", "}").Replace("\\","");
        foreach (var item in elemInfo.arrayItems)
        {
            var dict = JsonSerializer.Deserialize<Dictionary<string, object>>(item.ToString());
            if (!(string.IsNullOrEmpty(dict.GetValueOrDefault("from", "").ToString()) | string.IsNullOrEmpty(dict.GetValueOrDefault("to", "").ToString())
                  | !TryParseToType(dict.GetValueOrDefault("from", "").ToString(), ElemType.Int) | !TryParseToType(dict.GetValueOrDefault("to", "").ToString(), ElemType.Int))) continue;
            elemInfo.isValid = false;
            break;
        }
        await SendValue.InvokeAsync(elemInfo);
    }
    private void AddElementAttributes(ElemInfo? elemInfo)
    {
        switch (elemInfo?.control)
        {
            case Control.Text:
                ElementAttributes?.Add("type","text");
                break;
            case Control.Password:
                ElementAttributes?.Add("type","password");
                break;
            case Control.Date:
                ElementAttributes?.Add("type","date");
                break;
            case Control.Datetime:
                ElementAttributes?.Add("type","datetime-local");
                break;
            case Control.Time:
                ElementAttributes?.Add("type","time");
                break;
            case Control.Number:
                ElementAttributes?.Add("type","number");
                break;
            case Control.Checkbox:
                ElementAttributes?.Add("type","checkbox");
                ElementAttributes?.Add("checked", bool.Parse(Value.ToString()));
                break;
            case Control.Fieldset:
                break;
        }
        if (elemInfo.constraints is null)
        {
            elemInfo.constraints = new List<ConstraintItem>();
        }
        foreach (var constraint in elemInfo.constraints)
        {
            ElementAttributes?.Add(constraint.type, constraint.value);
        }
    }

    private async Task RemoveArrayItem(int pos)
    {
        elemInfo?.arrayItems.RemoveAt(pos);
        elemInfo.value = JsonSerializer.Serialize(elemInfo.arrayItems,options).Replace("\"{", "{").Replace("}\"", "}").Replace("\\","");
        await SendValue.InvokeAsync(elemInfo);
    }

    private void AddItem()
    {
        if (elemInfo?.sub_type == ElemType.Range)
        {
            var dictionary = new Dictionary<string, object>()
            {
                { "from", 0},
                { "to", 0}

            };
            elemInfo?.arrayItems.Add(JsonSerializer.Serialize(dictionary,options));
        }
        else
        {
            elemInfo?.arrayItems.Add(string.Empty);
        }
    }

    private bool CheckConstraints(string value, ConstraintItem constraintItem,Control control)
    {
        return constraintItem.type switch
        {
            "maxlength" => int.Parse(constraintItem.value) > value.Length,
            "minlength" => int.Parse(constraintItem.value) < value.Length,
            "max" => control switch
            {
                Control.Number or Control.Text or Control.Textarea => int.Parse(constraintItem.value) > int.Parse(value),
                Control.Datetime or Control.Date or Control.Time => DateTime.Parse(constraintItem.value) > DateTime.Parse(value),
                _ => true
                },
            "min" => control switch
            {
                Control.Number or Control.Text or Control.Textarea => int.Parse(constraintItem.value) < int.Parse(value),
                Control.Datetime or Control.Date or Control.Time => DateTime.Parse(constraintItem.value) < DateTime.Parse(value),
                _ => true
                },
            "pattern" => Regex.IsMatch(value, constraintItem.value, RegexOptions.IgnoreCase),
            _ => true
            };
    }

}